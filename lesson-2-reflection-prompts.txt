What happens when you initialize a repository? Why do you need to do it?
	Ans: when you initialize a repository, a .git file is created. And someone cannot just see it when the repository in open.
	the initialization is needed as it then allows the user to perform git command to the repository.

How is the staging area different from the working directory and the repository? What value do you think it offers?
	Ans: I believe that the difference between the working directory and the staging area, is that first the staging area is the intermediate state between the working directory and the repository. one can make as many changes to a file in the working directory but until the file is added to the staging area (git add), those changes would not appear in the staging area. and to go from the working directory to the repository, one has to add or go through the staging area. The repository is where we find all the changes made to a file once the changes have been commited from the staging area( git commit). I believe that the value that this gives us is the freedom to work and make changes as developer without having the fear of breaking the code. we can work in the working directory and test our code, and in case we break the code. thanks to the code being saved in the repository, we can reverse our changes and pinpoint what line introduced the bug without taking too long debugging. And that gives us the ability to be creative.

How can you use the staging area to make sure you have one commit per logical change?
	Ans:  We can modify as many files as we want in the working directory, but only add files in the staging area that are relevant to one logical change before commiting them to the repository. So the staging area allows us to break our files in different logical changes to be commited in the repository.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?
	Ans: I picture a situation where there is a release coming over the weekend, and the code has been tested and is ready to go. That code is stored in the Master branch. Let's say that I would like to test some few modification to the code that might be helpful but that are not required and that I am not sure to have fully completed before the release day, I can just create a new branch, and have the freedom to work in it without first the pressure of time and second without the pressure of breaking the code.Also, I can create other branches from this new let's call it developer branch to test new separate features. Let's call them Rose, Sunflower, and lilac branches. so I have 5 different branches that are helping me work in a very organized way, while still having code ready for release, instead of just waiting after the release by fear of breaking the code to start working. so I believe again that branching does not only help in history organization but also emphasis the use of git in allowing creativity and freedom to develop without fear of breaking what is already working.

How do the diagrams help you visualize the branch structure?
	Ans: the diagram helps me visualize the branch structure as it broke down a complex idea into simple steps.
	I could easily see what commits are accessible from a branch, and those that are not. Also what commits belong to another branch. The diagram also made it easy to understand the merging process, and knowing what commits would still be available and accessible once the merge is done and those that would not be able to show or be accessible directly from the new branch.

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
	 Ans: the Result of merging two branches together is a new branch from which you can access commits from the two different branches that was not possible before the merge. I believe that we represent merging in a diagram to not only make it easy to understand but to also show what commits will be accessible once the merge is complete. That allows us to make sure that we are not missing any commit that would be needed in the new merge. 

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?
	Ans:Git automatic merging I believe helps us save a lot of time.In cases where multiple people are working together, merging all those changes manually would be time consuming but I believe that it would also open a door for some errors.
	On the other hand, automatic merging can introduces changes that would break the code.For example, as we saw with the diagram, let's say in one branch a function is deleted, and in another branch we actually make a call to that function. When the merge occurs Git has no way of knowing not to introduce the call to the function, so it will introduce both changes, but once we run the merged version, we will have a bug.